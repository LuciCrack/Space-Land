<!DOCTYPE html>
<html>
<head>
  <title>Visor 3D</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/RGBELoader.js"></script>

  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 5000);

    // Transparent canvas + better color management
    const renderer = new THREE.WebGLRenderer({ antialias:true, logarithmicDepthBuffer:true, alpha:true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.setClearColor(0x000000, 0);                 // keep your transparent BG
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.physicallyCorrectLights = true;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.25;
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Blender-ish lighting
    const sun = new THREE.DirectionalLight(0xffffff, 4.0);
    sun.position.set(6, 10, 4);
    sun.castShadow = true;
    scene.add(sun);
    scene.add(new THREE.HemisphereLight(0xffffff, 0x777777, 0.8));

    // Optional: HDR environment for nicer materials (keeps canvas transparent because we DON'T set scene.background)
    // new THREE.RGBELoader().setPath('/static/hdr/').load('studio.hdr', (hdr) => {
    //   hdr.mapping = THREE.EquirectangularReflectionMapping;
    //   scene.environment = hdr; // reflections only; background stays transparent
    // });

    // Load model (keeps your icon/transparency handling exactly as you wrote it)
    let gltfScene = null;
    let targetRotation = -Math.PI / 4; // -90 degrees in radians
    let animationActive = false;
    let cameraStartDist = 0;
    let cameraEndDist = 0;
    let cameraStartPos = null;
    let cameraEndPos = null;
    let cameraStartY = 0;
    let cameraEndY = 0;

    const loader = new THREE.GLTFLoader();
    loader.load('/static/domo5.glb', (gltf) => {
      gltf.scene.traverse((child) => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
          child.material.flatShading = false;
          child.material.needsUpdate = true;

          // Your icon/alpha fix
          if (child.material.map && child.material.map.format === THREE.RGBAFormat) {
            child.material.transparent = true;
            child.material.alphaTest = 0.01;
          }
        }
      });

      gltfScene = gltf.scene;
      gltfScene.rotation.y = 0; // Start at 0
      scene.add(gltfScene);

      // Frame camera (prepare for animated zoom)
      const box = new THREE.Box3().setFromObject(gltf.scene);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);

      cameraStartDist = maxDim * 1.5; // initial (far)
      cameraEndDist = maxDim * 0.2;   // final (zoomed in 3x)
      cameraStartY = center.y + cameraStartDist * 0.6;
      cameraEndY = center.y + cameraEndDist * 0.6;

      cameraStartPos = new THREE.Vector3(center.x + cameraStartDist, cameraStartY, center.z + cameraStartDist);
      cameraEndPos = new THREE.Vector3(center.x + cameraEndDist, cameraEndY, center.z + cameraEndDist);

      camera.position.copy(cameraStartPos);
      camera.near = 0.1; camera.far = cameraStartDist * 10; camera.updateProjectionMatrix();
      controls.target.copy(center); controls.update();

      animationActive = true;
    });

    function animate() {
      requestAnimationFrame(animate);

      // Only update controls if animation is finished
      if (!animationActive) {
        controls.enablePan = true;
        controls.enableRotate = true;
        controls.update();
      } else {
        controls.enablePan = false;
        controls.enableRotate = false;
      }

      // Animate initial rotation and zoom
      if (animationActive && gltfScene) {
        const speed = 0.02; // radians per frame (was 0.03, now much faster)
        let doneRot = false, doneZoom = false;

        // Animate rotation
        if (gltfScene.rotation.y > targetRotation) {
          gltfScene.rotation.y -= speed;
          if (gltfScene.rotation.y <= targetRotation) {
            gltfScene.rotation.y = targetRotation;
            doneRot = true;
          }
        } else {
          doneRot = true;
        }

        // Animate camera zoom
        const lerpSpeed = 0.06; // was 0.04, now much faster
        camera.position.lerp(cameraEndPos, lerpSpeed);
        if (camera.position.distanceTo(cameraEndPos) < 0.2) { // << increased threshold
          camera.position.copy(cameraEndPos);
          doneZoom = true;
        }

        if (doneRot && doneZoom) {
          animationActive = false;
        }
      }

      renderer.render(scene, camera);
    }
    animate();

    addEventListener('resize', () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
